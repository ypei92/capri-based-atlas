\section{Design}
\label{sec:design}

As mentioned in the motivation section, the orthogonal searching strategy used
\atl is quite problematic. It can only generate good results for some platforms
and the install process is slow. The high level idea to speed up \atl
optimization process as well as improving \gem performance is to replace the
original searching space by the new space generated by Capri.

The design of our Capri-based \atl can be separated into four parts: knob
selection, feature selection, the offline training phase and the online testing
phase. One \atl installation process generates linear algebra libraries for one
platform. Hence, the input to Capri is a particular platform. Some features are
extracted to represent the platform, such as type of cores, core frequency and
so on. Knobs, as descried in Section~\ref{sec:Capri_intro}, affects the
performance of any input of a target application. The offline training phase
captures the characteristics of the platform features and knob settings by doing
exhaustive runs. Capri uses the profiling data generated by exhaustive runs and
builds a model for the \gem performance. In the testing phase, the model takes
a platform and a ``top M'' constraint as input, and output the best predicted
knob setting for GEMM for this platform.

The detailed design are descried in the following for subsections.

  \subsection{Knob selection}
  \label{sec:knobs}
  As mentioned in Section~\ref{sec:atlas_intro}, \atl optimizes a set of knobs
  including {$NB$, $MU$, $NU$, $KU$, $L_s$, $FMA$, $F_F$, $I_F$, $N_F$} by
  using orthogonal search. Altogether there are 9 knobs here. $NB$, $MU$, $NU$
  and $KU$ have roughly 10$\sim$20 configurateable settings respectively, $L_s$,
  $F_F$, $I_F$ and $N_F$ have roughly 5$\sim$10 different settings respectively.
  $FMA$ has 2 settings. If all knobs are considered in the offline profiling
  process, the searching space is over 100 million for one platform, which is
  obviously inapplicatable in reality. Based on some careful study of the
  effect of knobs on \gem performance, we found out that only $NB$, $MU$, $NU$
  and $KU$ has significant effect on the performance, while other knobs only
  have minor($\sim$10\%) effect. Therefore, we choose $NB$, $MU$, $NU$ and $KU$
  as our knob space. The size of the joint space is around 12500, most
  platforms can finish these many runs in one day.

  \subsection{Feature selection}
  \label{sec:features}
  Features are used in Capri as the identification for different inputs. In this
  project, obviously platform features affects a lot. For example, processers
  from \emph{Intel, ARM} or \emph{AMD} performs really differently even with
  the some clock frequency. Or another example, performance on MAC OS and Linux
  are very different because the compiler used to generate code is very
  different. By inspecting \atl configurate step, we choose 6 featues as the
  indicators of one platform. We cannot tell the exact effect of each feature
  but the machine learning model can.
  \begin{itemize}
  \item Architecture categorized by \atl
  \item Compiler type
  \item Number of registers
  \item Size of the L1 instruction cache
  \item CPU frequency
  \item CPU benchmark performance\footnote{CPU score given by
  https://www.cpubenchmark.net/cpu\_list.php}
  \end{itemize}

  \begin{figure*}[tbhp]
    \centering
    \begin{subfigure}[b]{1.0\linewidth}
      \centering
      \includegraphics[width=0.9\textwidth]{images/offline_training.png}
      \caption{Offline training phase: \atl profiling and Capri model building}
      \label{fig:design_train}
    \end{subfigure}
    \begin{subfigure}[b]{1.0\linewidth}
      \centering
      \includegraphics[width=0.9\textwidth]{images/testing.png}
      \caption{Online testing phase: Capri model searching and \atl execution}
      \label{fig:design_test}
    \end{subfigure}
    \caption{Capri-based \atl design diagram}
  \end{figure*}

  \subsection{Offline Training}
  \label{sec:offline_training}
  The diagram of the offline training phase is shown in
  Fig.\ref{fig:design_train}. A interface is implemented in \atl in order to
  take knob settings as input, generate code and evaluate the performance of
  the input knob setting. 

  \subsection{Online Testing}
  \label{sec:online_training}

  \subsection{Machine Learing Model}
  \label{sec:maching_learning_model}



$mflops = f(platform, NB, MU, NU, KU)$
